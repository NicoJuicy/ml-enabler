import fs from 'fs';
import path from 'path';
import RL from 'readline';
import MBTiles from './mbtiles.js';
import BBox from './bbox.js';
import PNG from 'fast-png';
import colour from 'randomcolor';
import { Image } from 'image-js';
import tb from '@mapbox/tilebelt';

/**
 * @class
 * @param {String[]} palette Array of #RGB colour codes
 */
class B64PNG {
    constructor(palette) {
        if (palette.length === 256) {
            this.palette = palette;
        } else {
            this.palette = new Array(256).fill().map(() => {
                return colour({ format: 'rgb' })
                    .replace(/(rgb\(|\)|\s)/g, '')
                    .split(',')
                    .map((e) => parseInt(e));
            });

            if (palette) {
                for (let i = 0; i < palette.length; i++) {
                    this.palette[i] = B64PNG.hex2rgb(palette[i]);
                }
            }
        }
    }

    /**
     * Convert Hex String to RGB Array
     *
     * @param {string} hex Hex Code to convert
     * @returns {Number[]}
     */
    static hex2rgb(hex) {
        // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
        const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        hex = hex.replace(shorthandRegex, (m, r, g, b) => {
            return r + r + g + g + b + b;
        });

        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? [
            parseInt(result[1], 16),
            parseInt(result[2], 16),
            parseInt(result[3], 16)
        ] : null;
    }

    /**
     * Convert Line Delimited B64 images to a TileBase file
     *
     * @param {string}  input               Path to Image File
     * @param {object}  opts                Options Object
     * @param {string}  opts.tmp            Temp Directory Path
     * @param {string}  [opts.minzoom=6]    Minzoom to interpolate (underzoom) to
     */
    async convert(input, opts) {
        if (!opts.minzoom) opts.minzoom = 6;

        const bbox = new BBox();

        const mbtiles = await MBTiles.create(path.resolve(opts.tmp, 'fabric.mbtiles'));
        await mbtiles.startWriting();

        const rl = RL.createInterface({
            input: fs.createReadStream(input)
        });

        for await (let line of rl) {
            try {
                line = JSON.parse(line);
            } catch (err) {
                console.error(err, line);
                continue;
            }

            bbox.tile(line.z, line.x, line.y);

            await mbtiles.putTile(line.z, line.x, line.y, this.color(new Buffer.from(line.image, 'base64')));
        }

        if (!opts.silent) console.log('ok - finished writing base tiles');

        await mbtiles.stopWriting();

        const stack = bbox.gen_stack();

        // Generate Underzoom Tiles
        if (opts.minzoom < bbox.minzoom) {
            for (let z = bbox.minzoom - 1; z >= opts.minzoom; z--) {
                await mbtiles.startWriting();

                for (let x = stack[z].minx; x <= stack[z].maxx; x++) {
                    for (let y = stack[z].miny; y <= stack[z].maxy; y++) {
                        mbtiles.putTile(z, x, y, Buffer.from(await this.underzoom(mbtiles, x, y, z)));
                    }
                }

                await mbtiles.stopWriting();
            }
        }

        await mbtiles.startWriting();
        await mbtiles.putInfo({
            name: 'Fabric',
            description: 'Autogenerated',
            format: 'png',
            version: 2,
            minzoom: opts.minzoom,
            maxzoom: bbox.maxzoom,
            bounds: bbox.bbox.join(','),
            center: bbox.centre().concat([bbox.maxzoom]).join(',')
        });

        await mbtiles.stopWriting();

        if (!opts.silent) console.log('ok - finished writing MBTiles');
    }

    /**
     * Given a XYZ coordinate, generate a PNG Class tile from it's children
     *
     * @param {MBTiles} mbtiles     MBTiles instance
     * @param {Number}  x           X Coordinate
     * @param {Number}  y           Y Coordinate
     * @param {Number}  z           Z Coordinate
     */
    async underzoom(mbtiles, x, y, z) {
        const children = [];
        for (const child of tb.getChildren([x, y, z])) {
            const x = child[0];
            const y = child[1];
            const z = child[2];

            let image;
            try {
                image = await Image.load(await mbtiles.getTile(z, x, y));
            } catch (err) {
                image = new Image(256, 256, new Uint8Array(256 * 256 * 4), {
                    kind: 'RGBA'
                });

                // Add Transparency to Alpha channel
                for (let i = 0; i < image.data.length / 4; i++) {
                    image.data[i * 4 - 1] = 1;
                }
            }

            children.push({
                x, y, z, image
            });
        }

        // Sort so 0,0, 1,0, 0,1, 1,1
        children.sort((a, b) => {
            if (a.y < b.y) return -1;
            if (a.y > b.y) return 1;
            if (a.x < b.x) return -1;
            if (a.x > b.x) return 1;
            return 0;
        });

        let full = new Image(512, 512, new Uint8Array(512 * 512 * 4), {
            kind: 'RGBA'
        });

        full.insert(children[0].image.rgba8(), { x: 0,    y: 0,       inPlace: true });
        full.insert(children[1].image.rgba8(), { x: 256,  y: 0,       inPlace: true });
        full.insert(children[2].image.rgba8(), { x: 0,    y: 256,     inPlace: true });
        full.insert(children[3].image.rgba8(), { x: 256,  y: 256,     inPlace: true });

        full = full.resize({
            width: 256,
            height: 256
        });

        return exportPNG(full);
    }

    /**
     * Given a PNG Buffer, add colours based on class IDs
     *
     * @param {Buffer} buff PNG Buffer
     * @return {Buffer} PNG Buffer with palette
     */
    color(buff) {
        let png = PNG.decode(buff);
        png.palette = this.palette;
        png = exportPNG(loadPNGFromPalette(png));

        return Buffer.from(png);
    }

    class_mean(values) {
        const value = values.sort((a,b) => {
            values.filter((v) => v === a).length - values.filter((v) => v === b).length;
        }).pop();

        return value;
    }
}

// Internal Export FN
// https://github.com/image-js/image-js/blob/675bafe1ec5f78d2d5d36df67e14e254d27a1f2d/src/image/core/export.js#L25-L41
// Can't find a way to export to Buffer
function exportPNG(image, options = {}) {
    const data = {
        width: image.width,
        height: image.height,
        channels: image.channels,
        depth: image.bitDepth,
        data: image.data
    };

    if (data.depth === 1 || data.depth === 32) {
        data.depth = 8;
        data.channels = 4;
        data.data = image.getRGBAData();
    }

    return PNG.encode(data, options);
}

function loadPNGFromPalette(png) {
    const pixels = png.width * png.height;
    const channels = png.palette[0].length;
    const data = new Uint8Array(pixels * channels);
    const pixelsPerByte = 8 / png.depth;
    const factor = png.depth < 8 ? pixelsPerByte : 1;
    const mask = parseInt('1'.repeat(png.depth), 2);
    const hasAlpha = channels === 4;
    let dataIndex = 0;

    for (let i = 0; i < pixels; i++) {
        const index = Math.floor(i / factor);
        let value = png.data[index];
        if (png.depth < 8) {
            value =
                (value >>> (png.depth * (pixelsPerByte - 1 - (i % pixelsPerByte)))) &
                mask;
        }
        const paletteValue = png.palette[value];
        data[dataIndex++] = paletteValue[0];
        data[dataIndex++] = paletteValue[1];
        data[dataIndex++] = paletteValue[2];

        if (hasAlpha) {
            data[dataIndex++] = paletteValue[3];
        }
    }

    return new Image(png.width, png.height, data, {
        components: 3,
        alpha: hasAlpha,
        bitDepth: 8
    });
}

export default B64PNG;
