import fs from 'fs';
import path from 'path';
import RL from 'readline';
import MBTiles from './mbtiles.js';
import BBox from './bbox.js';
import PNG from 'fast-png';
import colour from 'randomcolor';
import { Image } from 'image-js';
import tb from '@mapbox/tilebelt';

/**
 * @class
 *
 * @param {Array} Palette
 */
class B64PNG {
    constructor(palette) {
        if (palette) {
            this.palette = palette;
        } else {
            this.palette = new Array(256).fill().map(() => {
                return colour({ format: 'rgb' })
                    .replace(/(rgb\(|\)|\s)/g, '')
                    .split(',')
                    .map((e) => parseInt(e));
            });
        }
    }

    /**
     * Convert Line Delimited B64 images to a TileBase file
     *
     * @param {string}  input               Path to Image File
     * @param {object}  opts                Options Object
     * @param {string}  opts.tmp            Temp Directory Path
     * @param {string}  [opts.minzoom=6]    Minzoom to interpolate (underzoom) to
     */
    async convert(input, opts) {
        if (!opts.minzoom) opts.minzoom = 6;

        const bbox = new BBox();

        const mbtiles = await MBTiles.create(path.resolve(opts.tmp, 'fabric.mbtiles'));
        await mbtiles.startWriting();

        const rl = RL.createInterface({
            input: fs.createReadStream(input)
        });

        for await (let line of rl) {
            try {
                line = JSON.parse(line);
            } catch (err) {
                console.error(err, line);
                continue;
            }

            bbox.tile(line.z, line.x, line.y);

            await mbtiles.putTile(line.z, line.x, line.y, new Buffer.from(line.image, 'base64'));
        }

        if (!opts.silent) console.log('ok - finished writing base tiles');

        await mbtiles.stopWriting();

        const stack = bbox.gen_stack();

        // Generate Underzoom Tiles
        if (opts.minzoom < bbox.minzoom) {
            for (let z = bbox.minzoom - 1; z >= opts.minzoom; z--) {
                await mbtiles.startWriting();

                for (let x = stack[z].minx; x <= stack[z].maxx; x++) {
                    for (let y = stack[z].miny; y <= stack[z].maxy; y++) {
                        mbtiles.putTile(z, x, y, Buffer.from(await this.overzoom(mbtiles, x, y, z)));
                    }
                }

                await mbtiles.stopWriting();
            }
        }

        if (!opts.silent) console.log('ok - starting colourize, finished underzoom');

        // Colourize Tiles
        if (opts.minzoom < bbox.minzoom) {
            const stack = bbox.gen_stack();

            for (let z = bbox.minzoom - 1; z >= opts.minzoom; z--) {
                await mbtiles.startWriting();

                for (let x = stack[z].minx; x <= stack[z].maxx; x++) {
                    for (let y = stack[z].miny; y <= stack[z].maxy; y++) {
                        await mbtiles.putTile(z, x, y, Buffer.from(this.color(await mbtiles.getTile(z, x, y))));
                    }
                }

                await mbtiles.stopWriting();
            }
        }

        if (!opts.silent) console.log('ok - writing info - finished colourize');

        await mbtiles.startWriting();
        await mbtiles.putInfo({
            name: 'Fabric',
            description: 'Autogenerated',
            format: 'png',
            version: 2,
            minzoom: opts.minzoom,
            maxzoom: bbox.maxzoom,
            bounds: bbox.bbox.join(','),
            center: bbox.centre().concat([bbox.maxzoom]).join(',')
        });

        await mbtiles.stopWriting();

        if (!opts.silent) console.log('ok - finished writing MBTiles');
    }

    /**
     * Given a XYZ coordinate, generate a PNG Class tile from it's children
     *
     * @param {MBTiles} mbtiles     MBTiles instance
     * @param {Number}  x           X Coordinate
     * @param {Number}  y           Y Coordinate
     * @param {Number}  z           Z Coordinate
     */
    async overzoom(mbtiles, x, y, z) {
        const parent = new Image(256, 256, [], {
            kind: 'RGB'
        });

        const children = [];
        for (const child of tb.getChildren([x, y, z])) {
            const x = child[0];
            const y = child[1];
            const z = child[2];

            let image;
            try {
                image = await image.load(await mbtiles.getTile(z, x, y));
            } catch (err) {
                image = new Image(256, 256, [], {
                    kind: 'RGB'
                });
            }

            children.push({
                x, y, z, image
            });
        }

        for (let i = 0; i < 256 * 256; i++) {
            const values = [];

            for (const child of children) {
                values.push(child.image.data.slice(i * child.image.channels, i * child.image.channels + child.image.channels))
            }

            const value = this.rgb_mean(values);

            parent.data.set(value, i * parent.channels);
        }

        return exportPNG(parent);
    }

    /**
     * Given a PNG Buffer, add colours based on class IDs
     *
     * @param {Buffer} buff PNG Buffer
     * @return {Buffer} PNG Buffer with palette
     */
    color(buff) {
        let png = PNG.decode(buff);
        png.palette = this.palette;
        png = exportPNG(loadPNGFromPalette(png));

        return png;
    }

    rgb_mean(values) {
        values = values.map((value) => {
            return value.reduce((prev, curr) => {
                // Hash values in to fixed length string by prepending 0s
                return prev + String(curr).padStart(3, '0');
            }, '');
        });

        const value = values.sort((a,b) => {
            values.filter(v => v === a).length - values.filter(v => v === b).length
        }).pop();

        return [
            parseInt(value.slice(0, 3)),
            parseInt(value.slice(3, 3 + 3)),
            parseInt(value.slice(6, 6 + 3)),
            parseInt(value.slice(9, 9 + 3))
        ]
    }
}

// Internal Export FN
// https://github.com/image-js/image-js/blob/675bafe1ec5f78d2d5d36df67e14e254d27a1f2d/src/image/core/export.js#L25-L41
// Can't find a way to export to Buffer
function exportPNG(image, options = {}) {
    const data = {
        width: image.width,
        height: image.height,
        channels: image.channels,
        depth: image.bitDepth,
        data: image.data
    };

    if (data.depth === 1 || data.depth === 32) {
        data.depth = 8;
        data.channels = 4;
        data.data = image.getRGBAData();
    }

    return PNG.encode(data, options);
}

function loadPNGFromPalette(png) {
    const pixels = png.width * png.height;
    const channels = png.palette[0].length;
    const data = new Uint8Array(pixels * channels);
    const pixelsPerByte = 8 / png.depth;
    const factor = png.depth < 8 ? pixelsPerByte : 1;
    const mask = parseInt('1'.repeat(png.depth), 2);
    const hasAlpha = channels === 4;
    let dataIndex = 0;

    for (let i = 0; i < pixels; i++) {
        const index = Math.floor(i / factor);
        let value = png.data[index];
        if (png.depth < 8) {
            value =
                (value >>> (png.depth * (pixelsPerByte - 1 - (i % pixelsPerByte)))) &
                mask;
        }
        const paletteValue = png.palette[value];
        data[dataIndex++] = paletteValue[0];
        data[dataIndex++] = paletteValue[1];
        data[dataIndex++] = paletteValue[2];

        if (hasAlpha) {
            data[dataIndex++] = paletteValue[3];
        }
    }

    return new Image(png.width, png.height, data, {
        components: 3,
        alpha: hasAlpha,
        bitDepth: 8
    });
}

export default B64PNG;
